A working application which will read the bus service data, according to the format contained in the sample file, and display it in the tree view. Data reading must be instigated by clicking on the single button on the UI and selecting the required source file.

The architecture is based on a fairly standard model-view-controller scheme, with the controller marshalling data between the model and the view in response to requests made by the view, which is also the main UI in this case. Data objects are typically abstracted through the use of interfaces and instances are created by a simple factory, according to implementing classes registered against the individual interfaces. This works well and instance lifespan is managed using simple reference counting.

Per the specification, the application only reads and displays the data although, obviously, it could easily be expanded to permit indirect editing of the model data via the view and output to disk file as well. 

A test project has been included in the project group and a single, rather toothless test unit has been added to test the source data line reader class through its interface. This demonstrates class "testability" and would normally be expanded to cover all applicable classes with more meaningful test cases.

The data in the model is held as a structure, with each item supported by a hash table for O(1) searching of owned items.

Tree nodes are only populated when expanding, rather than populating the entire tree in a single, potentially lengthy action although, with national bus services only running into tens of thousands (32600 bus assets in the UK as of 20/21), this might still not be too onerous.

One area for improvement is in formalised error handling. Expected errors arising from source data formatting, as well as unexpecteds like loss of data items, are anticipated and checked for in the code and then routed out to a logging interface. The file reading is protected and exceptions are caught and, again, routed out to logging. However, it would be preferable to centralise error handling and route all errors out to this by raising and catching exceptions for all error cases. In a more complex application, such an approach to errors would be important but for this example, the approach taken should suffice. 

CSV data which do not precisely conform to the format indicated in the example file ("operator name","service name","xxxxxxx") are ignored. In practice, it may be better to try to repair damaged data, particularly if the omission is simply a missing quote mark or comma, but the risk of injecting incorrect data exists so a conservative approach was taken, considering the absence of a specification for this. The file reading is handled line by line by a helper class (accessed via its interface) to minimise the memory overhead of this part of the process. An alternative approach would have been to use a built in data type such as a TStringList and use it with a delimiting character to load and parse the data (although a missing comma would pose a problem for this approach). The file reading code could be improved by including a mechanism to indicate progress to the view and on to the user. This would be particularly important where the CSV file were very large.
